// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_INSPECTORDATA_JVM_TOOLBOX_FLATBUFFERS_INSPECTOR_H_
#define FLATBUFFERS_GENERATED_INSPECTORDATA_JVM_TOOLBOX_FLATBUFFERS_INSPECTOR_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 9,
             "Non-compatible flatbuffers version included");

namespace jvm_toolbox_flatbuffers {
namespace inspector {

struct LineData;
struct LineDataBuilder;

struct JavaObject;
struct JavaObjectBuilder;

struct JavaMethod;
struct JavaMethodBuilder;

struct JavaField;
struct JavaFieldBuilder;

struct JavaClass;
struct JavaClassBuilder;

struct JavaStackFrame;
struct JavaStackFrameBuilder;

struct JavaThread;
struct JavaThreadBuilder;

struct LineData FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LineDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINE_NUMBER = 4,
    VT_BYTECODE_INDEX = 6
  };
  int32_t line_number() const {
    return GetField<int32_t>(VT_LINE_NUMBER, 0);
  }
  int32_t bytecode_index() const {
    return GetField<int32_t>(VT_BYTECODE_INDEX, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_LINE_NUMBER, 4) &&
           VerifyField<int32_t>(verifier, VT_BYTECODE_INDEX, 4) &&
           verifier.EndTable();
  }
};

struct LineDataBuilder {
  typedef LineData Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_line_number(int32_t line_number) {
    fbb_.AddElement<int32_t>(LineData::VT_LINE_NUMBER, line_number, 0);
  }
  void add_bytecode_index(int32_t bytecode_index) {
    fbb_.AddElement<int32_t>(LineData::VT_BYTECODE_INDEX, bytecode_index, 0);
  }
  explicit LineDataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LineData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LineData>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LineData> CreateLineData(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t line_number = 0,
    int32_t bytecode_index = 0) {
  LineDataBuilder builder_(_fbb);
  builder_.add_bytecode_index(bytecode_index);
  builder_.add_line_number(line_number);
  return builder_.Finish();
}

struct JavaObject FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef JavaObjectBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ADDRESS = 4,
    VT_SIZE = 6,
    VT_HASH_CODE = 8
  };
  int64_t address() const {
    return GetField<int64_t>(VT_ADDRESS, 0);
  }
  int32_t size() const {
    return GetField<int32_t>(VT_SIZE, 0);
  }
  int32_t hash_code() const {
    return GetField<int32_t>(VT_HASH_CODE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_ADDRESS, 8) &&
           VerifyField<int32_t>(verifier, VT_SIZE, 4) &&
           VerifyField<int32_t>(verifier, VT_HASH_CODE, 4) &&
           verifier.EndTable();
  }
};

struct JavaObjectBuilder {
  typedef JavaObject Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_address(int64_t address) {
    fbb_.AddElement<int64_t>(JavaObject::VT_ADDRESS, address, 0);
  }
  void add_size(int32_t size) {
    fbb_.AddElement<int32_t>(JavaObject::VT_SIZE, size, 0);
  }
  void add_hash_code(int32_t hash_code) {
    fbb_.AddElement<int32_t>(JavaObject::VT_HASH_CODE, hash_code, 0);
  }
  explicit JavaObjectBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<JavaObject> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<JavaObject>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<JavaObject> CreateJavaObject(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t address = 0,
    int32_t size = 0,
    int32_t hash_code = 0) {
  JavaObjectBuilder builder_(_fbb);
  builder_.add_address(address);
  builder_.add_hash_code(hash_code);
  builder_.add_size(size);
  return builder_.Finish();
}

struct JavaMethod FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef JavaMethodBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_SIGNATURE = 6,
    VT_GENERIC_SIGNATURE = 8,
    VT_DECLARING_CLASS = 10,
    VT_MODIFIERS = 12,
    VT_MAX_LOCALS = 14,
    VT_ARGUMENTS_SIZE = 16,
    VT_LINE_NUMBER_DATA = 18,
    VT_METHOD_START = 20,
    VT_METHOD_END = 22,
    VT_BYTECODES = 24,
    VT_IS_NATIVE = 26,
    VT_IS_SYNTHETIC = 28,
    VT_IS_OBSOLETE = 30,
    VT_ADDRESS = 32
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *signature() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SIGNATURE);
  }
  const ::flatbuffers::String *generic_signature() const {
    return GetPointer<const ::flatbuffers::String *>(VT_GENERIC_SIGNATURE);
  }
  const jvm_toolbox_flatbuffers::inspector::JavaClass *declaring_class() const {
    return GetPointer<const jvm_toolbox_flatbuffers::inspector::JavaClass *>(VT_DECLARING_CLASS);
  }
  int32_t modifiers() const {
    return GetField<int32_t>(VT_MODIFIERS, 0);
  }
  int32_t max_locals() const {
    return GetField<int32_t>(VT_MAX_LOCALS, 0);
  }
  int32_t arguments_size() const {
    return GetField<int32_t>(VT_ARGUMENTS_SIZE, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::LineData>> *line_number_data() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::LineData>> *>(VT_LINE_NUMBER_DATA);
  }
  int32_t method_start() const {
    return GetField<int32_t>(VT_METHOD_START, 0);
  }
  int32_t method_end() const {
    return GetField<int32_t>(VT_METHOD_END, 0);
  }
  const ::flatbuffers::Vector<int8_t> *bytecodes() const {
    return GetPointer<const ::flatbuffers::Vector<int8_t> *>(VT_BYTECODES);
  }
  bool is_native() const {
    return GetField<uint8_t>(VT_IS_NATIVE, 0) != 0;
  }
  bool is_synthetic() const {
    return GetField<uint8_t>(VT_IS_SYNTHETIC, 0) != 0;
  }
  bool is_obsolete() const {
    return GetField<uint8_t>(VT_IS_OBSOLETE, 0) != 0;
  }
  int64_t address() const {
    return GetField<int64_t>(VT_ADDRESS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_SIGNATURE) &&
           verifier.VerifyString(signature()) &&
           VerifyOffset(verifier, VT_GENERIC_SIGNATURE) &&
           verifier.VerifyString(generic_signature()) &&
           VerifyOffset(verifier, VT_DECLARING_CLASS) &&
           verifier.VerifyTable(declaring_class()) &&
           VerifyField<int32_t>(verifier, VT_MODIFIERS, 4) &&
           VerifyField<int32_t>(verifier, VT_MAX_LOCALS, 4) &&
           VerifyField<int32_t>(verifier, VT_ARGUMENTS_SIZE, 4) &&
           VerifyOffset(verifier, VT_LINE_NUMBER_DATA) &&
           verifier.VerifyVector(line_number_data()) &&
           verifier.VerifyVectorOfTables(line_number_data()) &&
           VerifyField<int32_t>(verifier, VT_METHOD_START, 4) &&
           VerifyField<int32_t>(verifier, VT_METHOD_END, 4) &&
           VerifyOffset(verifier, VT_BYTECODES) &&
           verifier.VerifyVector(bytecodes()) &&
           VerifyField<uint8_t>(verifier, VT_IS_NATIVE, 1) &&
           VerifyField<uint8_t>(verifier, VT_IS_SYNTHETIC, 1) &&
           VerifyField<uint8_t>(verifier, VT_IS_OBSOLETE, 1) &&
           VerifyField<int64_t>(verifier, VT_ADDRESS, 8) &&
           verifier.EndTable();
  }
};

struct JavaMethodBuilder {
  typedef JavaMethod Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(JavaMethod::VT_NAME, name);
  }
  void add_signature(::flatbuffers::Offset<::flatbuffers::String> signature) {
    fbb_.AddOffset(JavaMethod::VT_SIGNATURE, signature);
  }
  void add_generic_signature(::flatbuffers::Offset<::flatbuffers::String> generic_signature) {
    fbb_.AddOffset(JavaMethod::VT_GENERIC_SIGNATURE, generic_signature);
  }
  void add_declaring_class(::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaClass> declaring_class) {
    fbb_.AddOffset(JavaMethod::VT_DECLARING_CLASS, declaring_class);
  }
  void add_modifiers(int32_t modifiers) {
    fbb_.AddElement<int32_t>(JavaMethod::VT_MODIFIERS, modifiers, 0);
  }
  void add_max_locals(int32_t max_locals) {
    fbb_.AddElement<int32_t>(JavaMethod::VT_MAX_LOCALS, max_locals, 0);
  }
  void add_arguments_size(int32_t arguments_size) {
    fbb_.AddElement<int32_t>(JavaMethod::VT_ARGUMENTS_SIZE, arguments_size, 0);
  }
  void add_line_number_data(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::LineData>>> line_number_data) {
    fbb_.AddOffset(JavaMethod::VT_LINE_NUMBER_DATA, line_number_data);
  }
  void add_method_start(int32_t method_start) {
    fbb_.AddElement<int32_t>(JavaMethod::VT_METHOD_START, method_start, 0);
  }
  void add_method_end(int32_t method_end) {
    fbb_.AddElement<int32_t>(JavaMethod::VT_METHOD_END, method_end, 0);
  }
  void add_bytecodes(::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> bytecodes) {
    fbb_.AddOffset(JavaMethod::VT_BYTECODES, bytecodes);
  }
  void add_is_native(bool is_native) {
    fbb_.AddElement<uint8_t>(JavaMethod::VT_IS_NATIVE, static_cast<uint8_t>(is_native), 0);
  }
  void add_is_synthetic(bool is_synthetic) {
    fbb_.AddElement<uint8_t>(JavaMethod::VT_IS_SYNTHETIC, static_cast<uint8_t>(is_synthetic), 0);
  }
  void add_is_obsolete(bool is_obsolete) {
    fbb_.AddElement<uint8_t>(JavaMethod::VT_IS_OBSOLETE, static_cast<uint8_t>(is_obsolete), 0);
  }
  void add_address(int64_t address) {
    fbb_.AddElement<int64_t>(JavaMethod::VT_ADDRESS, address, 0);
  }
  explicit JavaMethodBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<JavaMethod> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<JavaMethod>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<JavaMethod> CreateJavaMethod(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> signature = 0,
    ::flatbuffers::Offset<::flatbuffers::String> generic_signature = 0,
    ::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaClass> declaring_class = 0,
    int32_t modifiers = 0,
    int32_t max_locals = 0,
    int32_t arguments_size = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::LineData>>> line_number_data = 0,
    int32_t method_start = 0,
    int32_t method_end = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> bytecodes = 0,
    bool is_native = false,
    bool is_synthetic = false,
    bool is_obsolete = false,
    int64_t address = 0) {
  JavaMethodBuilder builder_(_fbb);
  builder_.add_address(address);
  builder_.add_bytecodes(bytecodes);
  builder_.add_method_end(method_end);
  builder_.add_method_start(method_start);
  builder_.add_line_number_data(line_number_data);
  builder_.add_arguments_size(arguments_size);
  builder_.add_max_locals(max_locals);
  builder_.add_modifiers(modifiers);
  builder_.add_declaring_class(declaring_class);
  builder_.add_generic_signature(generic_signature);
  builder_.add_signature(signature);
  builder_.add_name(name);
  builder_.add_is_obsolete(is_obsolete);
  builder_.add_is_synthetic(is_synthetic);
  builder_.add_is_native(is_native);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<JavaMethod> CreateJavaMethodDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *signature = nullptr,
    const char *generic_signature = nullptr,
    ::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaClass> declaring_class = 0,
    int32_t modifiers = 0,
    int32_t max_locals = 0,
    int32_t arguments_size = 0,
    const std::vector<::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::LineData>> *line_number_data = nullptr,
    int32_t method_start = 0,
    int32_t method_end = 0,
    const std::vector<int8_t> *bytecodes = nullptr,
    bool is_native = false,
    bool is_synthetic = false,
    bool is_obsolete = false,
    int64_t address = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto signature__ = signature ? _fbb.CreateString(signature) : 0;
  auto generic_signature__ = generic_signature ? _fbb.CreateString(generic_signature) : 0;
  auto line_number_data__ = line_number_data ? _fbb.CreateVector<::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::LineData>>(*line_number_data) : 0;
  auto bytecodes__ = bytecodes ? _fbb.CreateVector<int8_t>(*bytecodes) : 0;
  return jvm_toolbox_flatbuffers::inspector::CreateJavaMethod(
      _fbb,
      name__,
      signature__,
      generic_signature__,
      declaring_class,
      modifiers,
      max_locals,
      arguments_size,
      line_number_data__,
      method_start,
      method_end,
      bytecodes__,
      is_native,
      is_synthetic,
      is_obsolete,
      address);
}

struct JavaField FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef JavaFieldBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_SIGNATURE = 6,
    VT_GENERIC_SIGNATURE = 8,
    VT_DECLARING_CLASS = 10,
    VT_MODIFIERS = 12,
    VT_OFFSET = 14,
    VT_IS_SYNTHETIC = 16,
    VT_FIELD_ID = 18
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *signature() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SIGNATURE);
  }
  const ::flatbuffers::String *generic_signature() const {
    return GetPointer<const ::flatbuffers::String *>(VT_GENERIC_SIGNATURE);
  }
  const jvm_toolbox_flatbuffers::inspector::JavaClass *declaring_class() const {
    return GetPointer<const jvm_toolbox_flatbuffers::inspector::JavaClass *>(VT_DECLARING_CLASS);
  }
  int32_t modifiers() const {
    return GetField<int32_t>(VT_MODIFIERS, 0);
  }
  int16_t offset() const {
    return GetField<int16_t>(VT_OFFSET, 0);
  }
  bool is_synthetic() const {
    return GetField<uint8_t>(VT_IS_SYNTHETIC, 0) != 0;
  }
  int64_t field_id() const {
    return GetField<int64_t>(VT_FIELD_ID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_SIGNATURE) &&
           verifier.VerifyString(signature()) &&
           VerifyOffset(verifier, VT_GENERIC_SIGNATURE) &&
           verifier.VerifyString(generic_signature()) &&
           VerifyOffset(verifier, VT_DECLARING_CLASS) &&
           verifier.VerifyTable(declaring_class()) &&
           VerifyField<int32_t>(verifier, VT_MODIFIERS, 4) &&
           VerifyField<int16_t>(verifier, VT_OFFSET, 2) &&
           VerifyField<uint8_t>(verifier, VT_IS_SYNTHETIC, 1) &&
           VerifyField<int64_t>(verifier, VT_FIELD_ID, 8) &&
           verifier.EndTable();
  }
};

struct JavaFieldBuilder {
  typedef JavaField Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(JavaField::VT_NAME, name);
  }
  void add_signature(::flatbuffers::Offset<::flatbuffers::String> signature) {
    fbb_.AddOffset(JavaField::VT_SIGNATURE, signature);
  }
  void add_generic_signature(::flatbuffers::Offset<::flatbuffers::String> generic_signature) {
    fbb_.AddOffset(JavaField::VT_GENERIC_SIGNATURE, generic_signature);
  }
  void add_declaring_class(::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaClass> declaring_class) {
    fbb_.AddOffset(JavaField::VT_DECLARING_CLASS, declaring_class);
  }
  void add_modifiers(int32_t modifiers) {
    fbb_.AddElement<int32_t>(JavaField::VT_MODIFIERS, modifiers, 0);
  }
  void add_offset(int16_t offset) {
    fbb_.AddElement<int16_t>(JavaField::VT_OFFSET, offset, 0);
  }
  void add_is_synthetic(bool is_synthetic) {
    fbb_.AddElement<uint8_t>(JavaField::VT_IS_SYNTHETIC, static_cast<uint8_t>(is_synthetic), 0);
  }
  void add_field_id(int64_t field_id) {
    fbb_.AddElement<int64_t>(JavaField::VT_FIELD_ID, field_id, 0);
  }
  explicit JavaFieldBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<JavaField> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<JavaField>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<JavaField> CreateJavaField(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> signature = 0,
    ::flatbuffers::Offset<::flatbuffers::String> generic_signature = 0,
    ::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaClass> declaring_class = 0,
    int32_t modifiers = 0,
    int16_t offset = 0,
    bool is_synthetic = false,
    int64_t field_id = 0) {
  JavaFieldBuilder builder_(_fbb);
  builder_.add_field_id(field_id);
  builder_.add_modifiers(modifiers);
  builder_.add_declaring_class(declaring_class);
  builder_.add_generic_signature(generic_signature);
  builder_.add_signature(signature);
  builder_.add_name(name);
  builder_.add_offset(offset);
  builder_.add_is_synthetic(is_synthetic);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<JavaField> CreateJavaFieldDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *signature = nullptr,
    const char *generic_signature = nullptr,
    ::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaClass> declaring_class = 0,
    int32_t modifiers = 0,
    int16_t offset = 0,
    bool is_synthetic = false,
    int64_t field_id = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto signature__ = signature ? _fbb.CreateString(signature) : 0;
  auto generic_signature__ = generic_signature ? _fbb.CreateString(generic_signature) : 0;
  return jvm_toolbox_flatbuffers::inspector::CreateJavaField(
      _fbb,
      name__,
      signature__,
      generic_signature__,
      declaring_class,
      modifiers,
      offset,
      is_synthetic,
      field_id);
}

struct JavaClass FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef JavaClassBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SIGNATURE = 4,
    VT_SOURCE_FILE_NAMNE = 6,
    VT_STATUS = 8,
    VT_MODIFIERS = 10,
    VT_MINOR_VERSION = 12,
    VT_MAJOR_VERSION = 14,
    VT_IS_INTERFACE = 16,
    VT_IS_ARRAY = 18,
    VT_ADDRESS = 20,
    VT_METHODS = 22,
    VT_FIELDS = 24
  };
  const ::flatbuffers::String *signature() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SIGNATURE);
  }
  const ::flatbuffers::String *source_file_namne() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOURCE_FILE_NAMNE);
  }
  int16_t status() const {
    return GetField<int16_t>(VT_STATUS, 0);
  }
  int32_t modifiers() const {
    return GetField<int32_t>(VT_MODIFIERS, 0);
  }
  int32_t minor_version() const {
    return GetField<int32_t>(VT_MINOR_VERSION, 0);
  }
  int32_t major_version() const {
    return GetField<int32_t>(VT_MAJOR_VERSION, 0);
  }
  bool is_interface() const {
    return GetField<uint8_t>(VT_IS_INTERFACE, 0) != 0;
  }
  bool is_array() const {
    return GetField<uint8_t>(VT_IS_ARRAY, 0) != 0;
  }
  int64_t address() const {
    return GetField<int64_t>(VT_ADDRESS, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaMethod>> *methods() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaMethod>> *>(VT_METHODS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaField>> *fields() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaField>> *>(VT_FIELDS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SIGNATURE) &&
           verifier.VerifyString(signature()) &&
           VerifyOffset(verifier, VT_SOURCE_FILE_NAMNE) &&
           verifier.VerifyString(source_file_namne()) &&
           VerifyField<int16_t>(verifier, VT_STATUS, 2) &&
           VerifyField<int32_t>(verifier, VT_MODIFIERS, 4) &&
           VerifyField<int32_t>(verifier, VT_MINOR_VERSION, 4) &&
           VerifyField<int32_t>(verifier, VT_MAJOR_VERSION, 4) &&
           VerifyField<uint8_t>(verifier, VT_IS_INTERFACE, 1) &&
           VerifyField<uint8_t>(verifier, VT_IS_ARRAY, 1) &&
           VerifyField<int64_t>(verifier, VT_ADDRESS, 8) &&
           VerifyOffset(verifier, VT_METHODS) &&
           verifier.VerifyVector(methods()) &&
           verifier.VerifyVectorOfTables(methods()) &&
           VerifyOffset(verifier, VT_FIELDS) &&
           verifier.VerifyVector(fields()) &&
           verifier.VerifyVectorOfTables(fields()) &&
           verifier.EndTable();
  }
};

struct JavaClassBuilder {
  typedef JavaClass Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_signature(::flatbuffers::Offset<::flatbuffers::String> signature) {
    fbb_.AddOffset(JavaClass::VT_SIGNATURE, signature);
  }
  void add_source_file_namne(::flatbuffers::Offset<::flatbuffers::String> source_file_namne) {
    fbb_.AddOffset(JavaClass::VT_SOURCE_FILE_NAMNE, source_file_namne);
  }
  void add_status(int16_t status) {
    fbb_.AddElement<int16_t>(JavaClass::VT_STATUS, status, 0);
  }
  void add_modifiers(int32_t modifiers) {
    fbb_.AddElement<int32_t>(JavaClass::VT_MODIFIERS, modifiers, 0);
  }
  void add_minor_version(int32_t minor_version) {
    fbb_.AddElement<int32_t>(JavaClass::VT_MINOR_VERSION, minor_version, 0);
  }
  void add_major_version(int32_t major_version) {
    fbb_.AddElement<int32_t>(JavaClass::VT_MAJOR_VERSION, major_version, 0);
  }
  void add_is_interface(bool is_interface) {
    fbb_.AddElement<uint8_t>(JavaClass::VT_IS_INTERFACE, static_cast<uint8_t>(is_interface), 0);
  }
  void add_is_array(bool is_array) {
    fbb_.AddElement<uint8_t>(JavaClass::VT_IS_ARRAY, static_cast<uint8_t>(is_array), 0);
  }
  void add_address(int64_t address) {
    fbb_.AddElement<int64_t>(JavaClass::VT_ADDRESS, address, 0);
  }
  void add_methods(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaMethod>>> methods) {
    fbb_.AddOffset(JavaClass::VT_METHODS, methods);
  }
  void add_fields(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaField>>> fields) {
    fbb_.AddOffset(JavaClass::VT_FIELDS, fields);
  }
  explicit JavaClassBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<JavaClass> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<JavaClass>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<JavaClass> CreateJavaClass(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> signature = 0,
    ::flatbuffers::Offset<::flatbuffers::String> source_file_namne = 0,
    int16_t status = 0,
    int32_t modifiers = 0,
    int32_t minor_version = 0,
    int32_t major_version = 0,
    bool is_interface = false,
    bool is_array = false,
    int64_t address = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaMethod>>> methods = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaField>>> fields = 0) {
  JavaClassBuilder builder_(_fbb);
  builder_.add_address(address);
  builder_.add_fields(fields);
  builder_.add_methods(methods);
  builder_.add_major_version(major_version);
  builder_.add_minor_version(minor_version);
  builder_.add_modifiers(modifiers);
  builder_.add_source_file_namne(source_file_namne);
  builder_.add_signature(signature);
  builder_.add_status(status);
  builder_.add_is_array(is_array);
  builder_.add_is_interface(is_interface);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<JavaClass> CreateJavaClassDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *signature = nullptr,
    const char *source_file_namne = nullptr,
    int16_t status = 0,
    int32_t modifiers = 0,
    int32_t minor_version = 0,
    int32_t major_version = 0,
    bool is_interface = false,
    bool is_array = false,
    int64_t address = 0,
    const std::vector<::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaMethod>> *methods = nullptr,
    const std::vector<::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaField>> *fields = nullptr) {
  auto signature__ = signature ? _fbb.CreateString(signature) : 0;
  auto source_file_namne__ = source_file_namne ? _fbb.CreateString(source_file_namne) : 0;
  auto methods__ = methods ? _fbb.CreateVector<::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaMethod>>(*methods) : 0;
  auto fields__ = fields ? _fbb.CreateVector<::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaField>>(*fields) : 0;
  return jvm_toolbox_flatbuffers::inspector::CreateJavaClass(
      _fbb,
      signature__,
      source_file_namne__,
      status,
      modifiers,
      minor_version,
      major_version,
      is_interface,
      is_array,
      address,
      methods__,
      fields__);
}

struct JavaStackFrame FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef JavaStackFrameBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FRAME_COUNT = 4
  };
  int32_t frame_count() const {
    return GetField<int32_t>(VT_FRAME_COUNT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FRAME_COUNT, 4) &&
           verifier.EndTable();
  }
};

struct JavaStackFrameBuilder {
  typedef JavaStackFrame Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_frame_count(int32_t frame_count) {
    fbb_.AddElement<int32_t>(JavaStackFrame::VT_FRAME_COUNT, frame_count, 0);
  }
  explicit JavaStackFrameBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<JavaStackFrame> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<JavaStackFrame>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<JavaStackFrame> CreateJavaStackFrame(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t frame_count = 0) {
  JavaStackFrameBuilder builder_(_fbb);
  builder_.add_frame_count(frame_count);
  return builder_.Finish();
}

struct JavaThread FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef JavaThreadBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATE = 4,
    VT_NAME = 6,
    VT_PRIORITY = 8,
    VT_IS_DAEMON = 10
  };
  int32_t state() const {
    return GetField<int32_t>(VT_STATE, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  int32_t priority() const {
    return GetField<int32_t>(VT_PRIORITY, 0);
  }
  bool is_daemon() const {
    return GetField<uint8_t>(VT_IS_DAEMON, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_STATE, 4) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int32_t>(verifier, VT_PRIORITY, 4) &&
           VerifyField<uint8_t>(verifier, VT_IS_DAEMON, 1) &&
           verifier.EndTable();
  }
};

struct JavaThreadBuilder {
  typedef JavaThread Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_state(int32_t state) {
    fbb_.AddElement<int32_t>(JavaThread::VT_STATE, state, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(JavaThread::VT_NAME, name);
  }
  void add_priority(int32_t priority) {
    fbb_.AddElement<int32_t>(JavaThread::VT_PRIORITY, priority, 0);
  }
  void add_is_daemon(bool is_daemon) {
    fbb_.AddElement<uint8_t>(JavaThread::VT_IS_DAEMON, static_cast<uint8_t>(is_daemon), 0);
  }
  explicit JavaThreadBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<JavaThread> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<JavaThread>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<JavaThread> CreateJavaThread(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t state = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    int32_t priority = 0,
    bool is_daemon = false) {
  JavaThreadBuilder builder_(_fbb);
  builder_.add_priority(priority);
  builder_.add_name(name);
  builder_.add_state(state);
  builder_.add_is_daemon(is_daemon);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<JavaThread> CreateJavaThreadDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t state = 0,
    const char *name = nullptr,
    int32_t priority = 0,
    bool is_daemon = false) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return jvm_toolbox_flatbuffers::inspector::CreateJavaThread(
      _fbb,
      state,
      name__,
      priority,
      is_daemon);
}

}  // namespace inspector
}  // namespace jvm_toolbox_flatbuffers

#endif  // FLATBUFFERS_GENERATED_INSPECTORDATA_JVM_TOOLBOX_FLATBUFFERS_INSPECTOR_H_
