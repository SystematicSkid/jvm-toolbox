// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_INSPECTORDATA_JVM_TOOLBOX_FLATBUFFERS_INSPECTOR_H_
#define FLATBUFFERS_GENERATED_INSPECTORDATA_JVM_TOOLBOX_FLATBUFFERS_INSPECTOR_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 9,
             "Non-compatible flatbuffers version included");

namespace jvm_toolbox_flatbuffers {
namespace inspector {

struct LineData;
struct LineDataBuilder;

struct JavaObject;
struct JavaObjectBuilder;

struct JavaMethod;
struct JavaMethodBuilder;

struct JavaField;
struct JavaFieldBuilder;

struct JavaClass;
struct JavaClassBuilder;

struct JavaStackFrame;
struct JavaStackFrameBuilder;

struct JavaThread;
struct JavaThreadBuilder;

struct OnSingleStep;
struct OnSingleStepBuilder;

struct OnBreakpoint;
struct OnBreakpointBuilder;

struct OnFieldAccess;
struct OnFieldAccessBuilder;

struct OnFieldModification;
struct OnFieldModificationBuilder;

struct OnFramePop;
struct OnFramePopBuilder;

struct OnException;
struct OnExceptionBuilder;

struct OnExceptionCatch;
struct OnExceptionCatchBuilder;

struct OnThreadStart;
struct OnThreadStartBuilder;

struct OnThreadEnd;
struct OnThreadEndBuilder;

struct OnClassLoad;
struct OnClassLoadBuilder;

struct OnClassPrepare;
struct OnClassPrepareBuilder;

struct OnClassFileLoad;
struct OnClassFileLoadBuilder;

struct OnVMDeath;
struct OnVMDeathBuilder;

struct OnVMObjectAllocated;
struct OnVMObjectAllocatedBuilder;

struct OnVMObjectFree;
struct OnVMObjectFreeBuilder;

struct LineData FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LineDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINE_NUMBER = 4,
    VT_BYTECODE_INDEX = 6
  };
  int32_t line_number() const {
    return GetField<int32_t>(VT_LINE_NUMBER, 0);
  }
  int32_t bytecode_index() const {
    return GetField<int32_t>(VT_BYTECODE_INDEX, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_LINE_NUMBER, 4) &&
           VerifyField<int32_t>(verifier, VT_BYTECODE_INDEX, 4) &&
           verifier.EndTable();
  }
};

struct LineDataBuilder {
  typedef LineData Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_line_number(int32_t line_number) {
    fbb_.AddElement<int32_t>(LineData::VT_LINE_NUMBER, line_number, 0);
  }
  void add_bytecode_index(int32_t bytecode_index) {
    fbb_.AddElement<int32_t>(LineData::VT_BYTECODE_INDEX, bytecode_index, 0);
  }
  explicit LineDataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LineData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LineData>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LineData> CreateLineData(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t line_number = 0,
    int32_t bytecode_index = 0) {
  LineDataBuilder builder_(_fbb);
  builder_.add_bytecode_index(bytecode_index);
  builder_.add_line_number(line_number);
  return builder_.Finish();
}

struct JavaObject FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef JavaObjectBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ADDRESS = 4,
    VT_SIZE = 6,
    VT_HASH_CODE = 8
  };
  int64_t address() const {
    return GetField<int64_t>(VT_ADDRESS, 0);
  }
  int32_t size() const {
    return GetField<int32_t>(VT_SIZE, 0);
  }
  int32_t hash_code() const {
    return GetField<int32_t>(VT_HASH_CODE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_ADDRESS, 8) &&
           VerifyField<int32_t>(verifier, VT_SIZE, 4) &&
           VerifyField<int32_t>(verifier, VT_HASH_CODE, 4) &&
           verifier.EndTable();
  }
};

struct JavaObjectBuilder {
  typedef JavaObject Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_address(int64_t address) {
    fbb_.AddElement<int64_t>(JavaObject::VT_ADDRESS, address, 0);
  }
  void add_size(int32_t size) {
    fbb_.AddElement<int32_t>(JavaObject::VT_SIZE, size, 0);
  }
  void add_hash_code(int32_t hash_code) {
    fbb_.AddElement<int32_t>(JavaObject::VT_HASH_CODE, hash_code, 0);
  }
  explicit JavaObjectBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<JavaObject> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<JavaObject>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<JavaObject> CreateJavaObject(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t address = 0,
    int32_t size = 0,
    int32_t hash_code = 0) {
  JavaObjectBuilder builder_(_fbb);
  builder_.add_address(address);
  builder_.add_hash_code(hash_code);
  builder_.add_size(size);
  return builder_.Finish();
}

struct JavaMethod FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef JavaMethodBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_SIGNATURE = 6,
    VT_GENERIC_SIGNATURE = 8,
    VT_DECLARING_CLASS = 10,
    VT_MODIFIERS = 12,
    VT_MAX_LOCALS = 14,
    VT_ARGUMENTS_SIZE = 16,
    VT_LINE_NUMBER_DATA = 18,
    VT_METHOD_START = 20,
    VT_METHOD_END = 22,
    VT_BYTECODES = 24,
    VT_IS_NATIVE = 26,
    VT_IS_SYNTHETIC = 28,
    VT_IS_OBSOLETE = 30,
    VT_ADDRESS = 32
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *signature() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SIGNATURE);
  }
  const ::flatbuffers::String *generic_signature() const {
    return GetPointer<const ::flatbuffers::String *>(VT_GENERIC_SIGNATURE);
  }
  const jvm_toolbox_flatbuffers::inspector::JavaClass *declaring_class() const {
    return GetPointer<const jvm_toolbox_flatbuffers::inspector::JavaClass *>(VT_DECLARING_CLASS);
  }
  int32_t modifiers() const {
    return GetField<int32_t>(VT_MODIFIERS, 0);
  }
  int32_t max_locals() const {
    return GetField<int32_t>(VT_MAX_LOCALS, 0);
  }
  int32_t arguments_size() const {
    return GetField<int32_t>(VT_ARGUMENTS_SIZE, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::LineData>> *line_number_data() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::LineData>> *>(VT_LINE_NUMBER_DATA);
  }
  int32_t method_start() const {
    return GetField<int32_t>(VT_METHOD_START, 0);
  }
  int32_t method_end() const {
    return GetField<int32_t>(VT_METHOD_END, 0);
  }
  const ::flatbuffers::Vector<int8_t> *bytecodes() const {
    return GetPointer<const ::flatbuffers::Vector<int8_t> *>(VT_BYTECODES);
  }
  bool is_native() const {
    return GetField<uint8_t>(VT_IS_NATIVE, 0) != 0;
  }
  bool is_synthetic() const {
    return GetField<uint8_t>(VT_IS_SYNTHETIC, 0) != 0;
  }
  bool is_obsolete() const {
    return GetField<uint8_t>(VT_IS_OBSOLETE, 0) != 0;
  }
  int64_t address() const {
    return GetField<int64_t>(VT_ADDRESS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_SIGNATURE) &&
           verifier.VerifyString(signature()) &&
           VerifyOffset(verifier, VT_GENERIC_SIGNATURE) &&
           verifier.VerifyString(generic_signature()) &&
           VerifyOffset(verifier, VT_DECLARING_CLASS) &&
           verifier.VerifyTable(declaring_class()) &&
           VerifyField<int32_t>(verifier, VT_MODIFIERS, 4) &&
           VerifyField<int32_t>(verifier, VT_MAX_LOCALS, 4) &&
           VerifyField<int32_t>(verifier, VT_ARGUMENTS_SIZE, 4) &&
           VerifyOffset(verifier, VT_LINE_NUMBER_DATA) &&
           verifier.VerifyVector(line_number_data()) &&
           verifier.VerifyVectorOfTables(line_number_data()) &&
           VerifyField<int32_t>(verifier, VT_METHOD_START, 4) &&
           VerifyField<int32_t>(verifier, VT_METHOD_END, 4) &&
           VerifyOffset(verifier, VT_BYTECODES) &&
           verifier.VerifyVector(bytecodes()) &&
           VerifyField<uint8_t>(verifier, VT_IS_NATIVE, 1) &&
           VerifyField<uint8_t>(verifier, VT_IS_SYNTHETIC, 1) &&
           VerifyField<uint8_t>(verifier, VT_IS_OBSOLETE, 1) &&
           VerifyField<int64_t>(verifier, VT_ADDRESS, 8) &&
           verifier.EndTable();
  }
};

struct JavaMethodBuilder {
  typedef JavaMethod Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(JavaMethod::VT_NAME, name);
  }
  void add_signature(::flatbuffers::Offset<::flatbuffers::String> signature) {
    fbb_.AddOffset(JavaMethod::VT_SIGNATURE, signature);
  }
  void add_generic_signature(::flatbuffers::Offset<::flatbuffers::String> generic_signature) {
    fbb_.AddOffset(JavaMethod::VT_GENERIC_SIGNATURE, generic_signature);
  }
  void add_declaring_class(::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaClass> declaring_class) {
    fbb_.AddOffset(JavaMethod::VT_DECLARING_CLASS, declaring_class);
  }
  void add_modifiers(int32_t modifiers) {
    fbb_.AddElement<int32_t>(JavaMethod::VT_MODIFIERS, modifiers, 0);
  }
  void add_max_locals(int32_t max_locals) {
    fbb_.AddElement<int32_t>(JavaMethod::VT_MAX_LOCALS, max_locals, 0);
  }
  void add_arguments_size(int32_t arguments_size) {
    fbb_.AddElement<int32_t>(JavaMethod::VT_ARGUMENTS_SIZE, arguments_size, 0);
  }
  void add_line_number_data(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::LineData>>> line_number_data) {
    fbb_.AddOffset(JavaMethod::VT_LINE_NUMBER_DATA, line_number_data);
  }
  void add_method_start(int32_t method_start) {
    fbb_.AddElement<int32_t>(JavaMethod::VT_METHOD_START, method_start, 0);
  }
  void add_method_end(int32_t method_end) {
    fbb_.AddElement<int32_t>(JavaMethod::VT_METHOD_END, method_end, 0);
  }
  void add_bytecodes(::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> bytecodes) {
    fbb_.AddOffset(JavaMethod::VT_BYTECODES, bytecodes);
  }
  void add_is_native(bool is_native) {
    fbb_.AddElement<uint8_t>(JavaMethod::VT_IS_NATIVE, static_cast<uint8_t>(is_native), 0);
  }
  void add_is_synthetic(bool is_synthetic) {
    fbb_.AddElement<uint8_t>(JavaMethod::VT_IS_SYNTHETIC, static_cast<uint8_t>(is_synthetic), 0);
  }
  void add_is_obsolete(bool is_obsolete) {
    fbb_.AddElement<uint8_t>(JavaMethod::VT_IS_OBSOLETE, static_cast<uint8_t>(is_obsolete), 0);
  }
  void add_address(int64_t address) {
    fbb_.AddElement<int64_t>(JavaMethod::VT_ADDRESS, address, 0);
  }
  explicit JavaMethodBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<JavaMethod> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<JavaMethod>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<JavaMethod> CreateJavaMethod(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> signature = 0,
    ::flatbuffers::Offset<::flatbuffers::String> generic_signature = 0,
    ::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaClass> declaring_class = 0,
    int32_t modifiers = 0,
    int32_t max_locals = 0,
    int32_t arguments_size = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::LineData>>> line_number_data = 0,
    int32_t method_start = 0,
    int32_t method_end = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> bytecodes = 0,
    bool is_native = false,
    bool is_synthetic = false,
    bool is_obsolete = false,
    int64_t address = 0) {
  JavaMethodBuilder builder_(_fbb);
  builder_.add_address(address);
  builder_.add_bytecodes(bytecodes);
  builder_.add_method_end(method_end);
  builder_.add_method_start(method_start);
  builder_.add_line_number_data(line_number_data);
  builder_.add_arguments_size(arguments_size);
  builder_.add_max_locals(max_locals);
  builder_.add_modifiers(modifiers);
  builder_.add_declaring_class(declaring_class);
  builder_.add_generic_signature(generic_signature);
  builder_.add_signature(signature);
  builder_.add_name(name);
  builder_.add_is_obsolete(is_obsolete);
  builder_.add_is_synthetic(is_synthetic);
  builder_.add_is_native(is_native);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<JavaMethod> CreateJavaMethodDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *signature = nullptr,
    const char *generic_signature = nullptr,
    ::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaClass> declaring_class = 0,
    int32_t modifiers = 0,
    int32_t max_locals = 0,
    int32_t arguments_size = 0,
    const std::vector<::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::LineData>> *line_number_data = nullptr,
    int32_t method_start = 0,
    int32_t method_end = 0,
    const std::vector<int8_t> *bytecodes = nullptr,
    bool is_native = false,
    bool is_synthetic = false,
    bool is_obsolete = false,
    int64_t address = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto signature__ = signature ? _fbb.CreateString(signature) : 0;
  auto generic_signature__ = generic_signature ? _fbb.CreateString(generic_signature) : 0;
  auto line_number_data__ = line_number_data ? _fbb.CreateVector<::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::LineData>>(*line_number_data) : 0;
  auto bytecodes__ = bytecodes ? _fbb.CreateVector<int8_t>(*bytecodes) : 0;
  return jvm_toolbox_flatbuffers::inspector::CreateJavaMethod(
      _fbb,
      name__,
      signature__,
      generic_signature__,
      declaring_class,
      modifiers,
      max_locals,
      arguments_size,
      line_number_data__,
      method_start,
      method_end,
      bytecodes__,
      is_native,
      is_synthetic,
      is_obsolete,
      address);
}

struct JavaField FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef JavaFieldBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_SIGNATURE = 6,
    VT_GENERIC_SIGNATURE = 8,
    VT_DECLARING_CLASS = 10,
    VT_MODIFIERS = 12,
    VT_OFFSET = 14,
    VT_IS_SYNTHETIC = 16,
    VT_FIELD_ID = 18
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *signature() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SIGNATURE);
  }
  const ::flatbuffers::String *generic_signature() const {
    return GetPointer<const ::flatbuffers::String *>(VT_GENERIC_SIGNATURE);
  }
  const jvm_toolbox_flatbuffers::inspector::JavaClass *declaring_class() const {
    return GetPointer<const jvm_toolbox_flatbuffers::inspector::JavaClass *>(VT_DECLARING_CLASS);
  }
  int32_t modifiers() const {
    return GetField<int32_t>(VT_MODIFIERS, 0);
  }
  int16_t offset() const {
    return GetField<int16_t>(VT_OFFSET, 0);
  }
  bool is_synthetic() const {
    return GetField<uint8_t>(VT_IS_SYNTHETIC, 0) != 0;
  }
  int64_t field_id() const {
    return GetField<int64_t>(VT_FIELD_ID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_SIGNATURE) &&
           verifier.VerifyString(signature()) &&
           VerifyOffset(verifier, VT_GENERIC_SIGNATURE) &&
           verifier.VerifyString(generic_signature()) &&
           VerifyOffset(verifier, VT_DECLARING_CLASS) &&
           verifier.VerifyTable(declaring_class()) &&
           VerifyField<int32_t>(verifier, VT_MODIFIERS, 4) &&
           VerifyField<int16_t>(verifier, VT_OFFSET, 2) &&
           VerifyField<uint8_t>(verifier, VT_IS_SYNTHETIC, 1) &&
           VerifyField<int64_t>(verifier, VT_FIELD_ID, 8) &&
           verifier.EndTable();
  }
};

struct JavaFieldBuilder {
  typedef JavaField Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(JavaField::VT_NAME, name);
  }
  void add_signature(::flatbuffers::Offset<::flatbuffers::String> signature) {
    fbb_.AddOffset(JavaField::VT_SIGNATURE, signature);
  }
  void add_generic_signature(::flatbuffers::Offset<::flatbuffers::String> generic_signature) {
    fbb_.AddOffset(JavaField::VT_GENERIC_SIGNATURE, generic_signature);
  }
  void add_declaring_class(::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaClass> declaring_class) {
    fbb_.AddOffset(JavaField::VT_DECLARING_CLASS, declaring_class);
  }
  void add_modifiers(int32_t modifiers) {
    fbb_.AddElement<int32_t>(JavaField::VT_MODIFIERS, modifiers, 0);
  }
  void add_offset(int16_t offset) {
    fbb_.AddElement<int16_t>(JavaField::VT_OFFSET, offset, 0);
  }
  void add_is_synthetic(bool is_synthetic) {
    fbb_.AddElement<uint8_t>(JavaField::VT_IS_SYNTHETIC, static_cast<uint8_t>(is_synthetic), 0);
  }
  void add_field_id(int64_t field_id) {
    fbb_.AddElement<int64_t>(JavaField::VT_FIELD_ID, field_id, 0);
  }
  explicit JavaFieldBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<JavaField> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<JavaField>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<JavaField> CreateJavaField(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> signature = 0,
    ::flatbuffers::Offset<::flatbuffers::String> generic_signature = 0,
    ::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaClass> declaring_class = 0,
    int32_t modifiers = 0,
    int16_t offset = 0,
    bool is_synthetic = false,
    int64_t field_id = 0) {
  JavaFieldBuilder builder_(_fbb);
  builder_.add_field_id(field_id);
  builder_.add_modifiers(modifiers);
  builder_.add_declaring_class(declaring_class);
  builder_.add_generic_signature(generic_signature);
  builder_.add_signature(signature);
  builder_.add_name(name);
  builder_.add_offset(offset);
  builder_.add_is_synthetic(is_synthetic);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<JavaField> CreateJavaFieldDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *signature = nullptr,
    const char *generic_signature = nullptr,
    ::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaClass> declaring_class = 0,
    int32_t modifiers = 0,
    int16_t offset = 0,
    bool is_synthetic = false,
    int64_t field_id = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto signature__ = signature ? _fbb.CreateString(signature) : 0;
  auto generic_signature__ = generic_signature ? _fbb.CreateString(generic_signature) : 0;
  return jvm_toolbox_flatbuffers::inspector::CreateJavaField(
      _fbb,
      name__,
      signature__,
      generic_signature__,
      declaring_class,
      modifiers,
      offset,
      is_synthetic,
      field_id);
}

struct JavaClass FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef JavaClassBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SIGNATURE = 4,
    VT_SOURCE_FILE_NAMNE = 6,
    VT_STATUS = 8,
    VT_MODIFIERS = 10,
    VT_MINOR_VERSION = 12,
    VT_MAJOR_VERSION = 14,
    VT_IS_INTERFACE = 16,
    VT_IS_ARRAY = 18,
    VT_ADDRESS = 20,
    VT_METHODS = 22,
    VT_FIELDS = 24
  };
  const ::flatbuffers::String *signature() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SIGNATURE);
  }
  const ::flatbuffers::String *source_file_namne() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOURCE_FILE_NAMNE);
  }
  int16_t status() const {
    return GetField<int16_t>(VT_STATUS, 0);
  }
  int32_t modifiers() const {
    return GetField<int32_t>(VT_MODIFIERS, 0);
  }
  int32_t minor_version() const {
    return GetField<int32_t>(VT_MINOR_VERSION, 0);
  }
  int32_t major_version() const {
    return GetField<int32_t>(VT_MAJOR_VERSION, 0);
  }
  bool is_interface() const {
    return GetField<uint8_t>(VT_IS_INTERFACE, 0) != 0;
  }
  bool is_array() const {
    return GetField<uint8_t>(VT_IS_ARRAY, 0) != 0;
  }
  int64_t address() const {
    return GetField<int64_t>(VT_ADDRESS, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaMethod>> *methods() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaMethod>> *>(VT_METHODS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaField>> *fields() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaField>> *>(VT_FIELDS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SIGNATURE) &&
           verifier.VerifyString(signature()) &&
           VerifyOffset(verifier, VT_SOURCE_FILE_NAMNE) &&
           verifier.VerifyString(source_file_namne()) &&
           VerifyField<int16_t>(verifier, VT_STATUS, 2) &&
           VerifyField<int32_t>(verifier, VT_MODIFIERS, 4) &&
           VerifyField<int32_t>(verifier, VT_MINOR_VERSION, 4) &&
           VerifyField<int32_t>(verifier, VT_MAJOR_VERSION, 4) &&
           VerifyField<uint8_t>(verifier, VT_IS_INTERFACE, 1) &&
           VerifyField<uint8_t>(verifier, VT_IS_ARRAY, 1) &&
           VerifyField<int64_t>(verifier, VT_ADDRESS, 8) &&
           VerifyOffset(verifier, VT_METHODS) &&
           verifier.VerifyVector(methods()) &&
           verifier.VerifyVectorOfTables(methods()) &&
           VerifyOffset(verifier, VT_FIELDS) &&
           verifier.VerifyVector(fields()) &&
           verifier.VerifyVectorOfTables(fields()) &&
           verifier.EndTable();
  }
};

struct JavaClassBuilder {
  typedef JavaClass Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_signature(::flatbuffers::Offset<::flatbuffers::String> signature) {
    fbb_.AddOffset(JavaClass::VT_SIGNATURE, signature);
  }
  void add_source_file_namne(::flatbuffers::Offset<::flatbuffers::String> source_file_namne) {
    fbb_.AddOffset(JavaClass::VT_SOURCE_FILE_NAMNE, source_file_namne);
  }
  void add_status(int16_t status) {
    fbb_.AddElement<int16_t>(JavaClass::VT_STATUS, status, 0);
  }
  void add_modifiers(int32_t modifiers) {
    fbb_.AddElement<int32_t>(JavaClass::VT_MODIFIERS, modifiers, 0);
  }
  void add_minor_version(int32_t minor_version) {
    fbb_.AddElement<int32_t>(JavaClass::VT_MINOR_VERSION, minor_version, 0);
  }
  void add_major_version(int32_t major_version) {
    fbb_.AddElement<int32_t>(JavaClass::VT_MAJOR_VERSION, major_version, 0);
  }
  void add_is_interface(bool is_interface) {
    fbb_.AddElement<uint8_t>(JavaClass::VT_IS_INTERFACE, static_cast<uint8_t>(is_interface), 0);
  }
  void add_is_array(bool is_array) {
    fbb_.AddElement<uint8_t>(JavaClass::VT_IS_ARRAY, static_cast<uint8_t>(is_array), 0);
  }
  void add_address(int64_t address) {
    fbb_.AddElement<int64_t>(JavaClass::VT_ADDRESS, address, 0);
  }
  void add_methods(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaMethod>>> methods) {
    fbb_.AddOffset(JavaClass::VT_METHODS, methods);
  }
  void add_fields(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaField>>> fields) {
    fbb_.AddOffset(JavaClass::VT_FIELDS, fields);
  }
  explicit JavaClassBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<JavaClass> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<JavaClass>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<JavaClass> CreateJavaClass(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> signature = 0,
    ::flatbuffers::Offset<::flatbuffers::String> source_file_namne = 0,
    int16_t status = 0,
    int32_t modifiers = 0,
    int32_t minor_version = 0,
    int32_t major_version = 0,
    bool is_interface = false,
    bool is_array = false,
    int64_t address = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaMethod>>> methods = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaField>>> fields = 0) {
  JavaClassBuilder builder_(_fbb);
  builder_.add_address(address);
  builder_.add_fields(fields);
  builder_.add_methods(methods);
  builder_.add_major_version(major_version);
  builder_.add_minor_version(minor_version);
  builder_.add_modifiers(modifiers);
  builder_.add_source_file_namne(source_file_namne);
  builder_.add_signature(signature);
  builder_.add_status(status);
  builder_.add_is_array(is_array);
  builder_.add_is_interface(is_interface);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<JavaClass> CreateJavaClassDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *signature = nullptr,
    const char *source_file_namne = nullptr,
    int16_t status = 0,
    int32_t modifiers = 0,
    int32_t minor_version = 0,
    int32_t major_version = 0,
    bool is_interface = false,
    bool is_array = false,
    int64_t address = 0,
    const std::vector<::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaMethod>> *methods = nullptr,
    const std::vector<::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaField>> *fields = nullptr) {
  auto signature__ = signature ? _fbb.CreateString(signature) : 0;
  auto source_file_namne__ = source_file_namne ? _fbb.CreateString(source_file_namne) : 0;
  auto methods__ = methods ? _fbb.CreateVector<::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaMethod>>(*methods) : 0;
  auto fields__ = fields ? _fbb.CreateVector<::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaField>>(*fields) : 0;
  return jvm_toolbox_flatbuffers::inspector::CreateJavaClass(
      _fbb,
      signature__,
      source_file_namne__,
      status,
      modifiers,
      minor_version,
      major_version,
      is_interface,
      is_array,
      address,
      methods__,
      fields__);
}

struct JavaStackFrame FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef JavaStackFrameBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FRAME_COUNT = 4
  };
  int32_t frame_count() const {
    return GetField<int32_t>(VT_FRAME_COUNT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FRAME_COUNT, 4) &&
           verifier.EndTable();
  }
};

struct JavaStackFrameBuilder {
  typedef JavaStackFrame Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_frame_count(int32_t frame_count) {
    fbb_.AddElement<int32_t>(JavaStackFrame::VT_FRAME_COUNT, frame_count, 0);
  }
  explicit JavaStackFrameBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<JavaStackFrame> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<JavaStackFrame>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<JavaStackFrame> CreateJavaStackFrame(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t frame_count = 0) {
  JavaStackFrameBuilder builder_(_fbb);
  builder_.add_frame_count(frame_count);
  return builder_.Finish();
}

struct JavaThread FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef JavaThreadBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATE = 4,
    VT_NAME = 6,
    VT_PRIORITY = 8,
    VT_IS_DAEMON = 10
  };
  int32_t state() const {
    return GetField<int32_t>(VT_STATE, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  int32_t priority() const {
    return GetField<int32_t>(VT_PRIORITY, 0);
  }
  bool is_daemon() const {
    return GetField<uint8_t>(VT_IS_DAEMON, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_STATE, 4) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int32_t>(verifier, VT_PRIORITY, 4) &&
           VerifyField<uint8_t>(verifier, VT_IS_DAEMON, 1) &&
           verifier.EndTable();
  }
};

struct JavaThreadBuilder {
  typedef JavaThread Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_state(int32_t state) {
    fbb_.AddElement<int32_t>(JavaThread::VT_STATE, state, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(JavaThread::VT_NAME, name);
  }
  void add_priority(int32_t priority) {
    fbb_.AddElement<int32_t>(JavaThread::VT_PRIORITY, priority, 0);
  }
  void add_is_daemon(bool is_daemon) {
    fbb_.AddElement<uint8_t>(JavaThread::VT_IS_DAEMON, static_cast<uint8_t>(is_daemon), 0);
  }
  explicit JavaThreadBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<JavaThread> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<JavaThread>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<JavaThread> CreateJavaThread(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t state = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    int32_t priority = 0,
    bool is_daemon = false) {
  JavaThreadBuilder builder_(_fbb);
  builder_.add_priority(priority);
  builder_.add_name(name);
  builder_.add_state(state);
  builder_.add_is_daemon(is_daemon);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<JavaThread> CreateJavaThreadDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t state = 0,
    const char *name = nullptr,
    int32_t priority = 0,
    bool is_daemon = false) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return jvm_toolbox_flatbuffers::inspector::CreateJavaThread(
      _fbb,
      state,
      name__,
      priority,
      is_daemon);
}

struct OnSingleStep FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OnSingleStepBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_THREAD = 4,
    VT_METHOD = 6,
    VT_LOCATION = 8
  };
  const jvm_toolbox_flatbuffers::inspector::JavaThread *thread() const {
    return GetPointer<const jvm_toolbox_flatbuffers::inspector::JavaThread *>(VT_THREAD);
  }
  const jvm_toolbox_flatbuffers::inspector::JavaMethod *method() const {
    return GetPointer<const jvm_toolbox_flatbuffers::inspector::JavaMethod *>(VT_METHOD);
  }
  int64_t location() const {
    return GetField<int64_t>(VT_LOCATION, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_THREAD) &&
           verifier.VerifyTable(thread()) &&
           VerifyOffset(verifier, VT_METHOD) &&
           verifier.VerifyTable(method()) &&
           VerifyField<int64_t>(verifier, VT_LOCATION, 8) &&
           verifier.EndTable();
  }
};

struct OnSingleStepBuilder {
  typedef OnSingleStep Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_thread(::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaThread> thread) {
    fbb_.AddOffset(OnSingleStep::VT_THREAD, thread);
  }
  void add_method(::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaMethod> method) {
    fbb_.AddOffset(OnSingleStep::VT_METHOD, method);
  }
  void add_location(int64_t location) {
    fbb_.AddElement<int64_t>(OnSingleStep::VT_LOCATION, location, 0);
  }
  explicit OnSingleStepBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OnSingleStep> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OnSingleStep>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OnSingleStep> CreateOnSingleStep(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaThread> thread = 0,
    ::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaMethod> method = 0,
    int64_t location = 0) {
  OnSingleStepBuilder builder_(_fbb);
  builder_.add_location(location);
  builder_.add_method(method);
  builder_.add_thread(thread);
  return builder_.Finish();
}

struct OnBreakpoint FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OnBreakpointBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_THREAD = 4,
    VT_METHOD = 6,
    VT_LOCATION = 8
  };
  const jvm_toolbox_flatbuffers::inspector::JavaThread *thread() const {
    return GetPointer<const jvm_toolbox_flatbuffers::inspector::JavaThread *>(VT_THREAD);
  }
  const jvm_toolbox_flatbuffers::inspector::JavaMethod *method() const {
    return GetPointer<const jvm_toolbox_flatbuffers::inspector::JavaMethod *>(VT_METHOD);
  }
  int64_t location() const {
    return GetField<int64_t>(VT_LOCATION, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_THREAD) &&
           verifier.VerifyTable(thread()) &&
           VerifyOffset(verifier, VT_METHOD) &&
           verifier.VerifyTable(method()) &&
           VerifyField<int64_t>(verifier, VT_LOCATION, 8) &&
           verifier.EndTable();
  }
};

struct OnBreakpointBuilder {
  typedef OnBreakpoint Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_thread(::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaThread> thread) {
    fbb_.AddOffset(OnBreakpoint::VT_THREAD, thread);
  }
  void add_method(::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaMethod> method) {
    fbb_.AddOffset(OnBreakpoint::VT_METHOD, method);
  }
  void add_location(int64_t location) {
    fbb_.AddElement<int64_t>(OnBreakpoint::VT_LOCATION, location, 0);
  }
  explicit OnBreakpointBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OnBreakpoint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OnBreakpoint>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OnBreakpoint> CreateOnBreakpoint(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaThread> thread = 0,
    ::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaMethod> method = 0,
    int64_t location = 0) {
  OnBreakpointBuilder builder_(_fbb);
  builder_.add_location(location);
  builder_.add_method(method);
  builder_.add_thread(thread);
  return builder_.Finish();
}

struct OnFieldAccess FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OnFieldAccessBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_THREAD = 4,
    VT_METHOD = 6,
    VT_LOCATION = 8,
    VT_CLASS_ = 10,
    VT_OBJECT = 12,
    VT_FIELD = 14
  };
  const jvm_toolbox_flatbuffers::inspector::JavaThread *thread() const {
    return GetPointer<const jvm_toolbox_flatbuffers::inspector::JavaThread *>(VT_THREAD);
  }
  const jvm_toolbox_flatbuffers::inspector::JavaMethod *method() const {
    return GetPointer<const jvm_toolbox_flatbuffers::inspector::JavaMethod *>(VT_METHOD);
  }
  int64_t location() const {
    return GetField<int64_t>(VT_LOCATION, 0);
  }
  const jvm_toolbox_flatbuffers::inspector::JavaClass *class_() const {
    return GetPointer<const jvm_toolbox_flatbuffers::inspector::JavaClass *>(VT_CLASS_);
  }
  const jvm_toolbox_flatbuffers::inspector::JavaObject *object() const {
    return GetPointer<const jvm_toolbox_flatbuffers::inspector::JavaObject *>(VT_OBJECT);
  }
  const jvm_toolbox_flatbuffers::inspector::JavaField *field() const {
    return GetPointer<const jvm_toolbox_flatbuffers::inspector::JavaField *>(VT_FIELD);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_THREAD) &&
           verifier.VerifyTable(thread()) &&
           VerifyOffset(verifier, VT_METHOD) &&
           verifier.VerifyTable(method()) &&
           VerifyField<int64_t>(verifier, VT_LOCATION, 8) &&
           VerifyOffset(verifier, VT_CLASS_) &&
           verifier.VerifyTable(class_()) &&
           VerifyOffset(verifier, VT_OBJECT) &&
           verifier.VerifyTable(object()) &&
           VerifyOffset(verifier, VT_FIELD) &&
           verifier.VerifyTable(field()) &&
           verifier.EndTable();
  }
};

struct OnFieldAccessBuilder {
  typedef OnFieldAccess Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_thread(::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaThread> thread) {
    fbb_.AddOffset(OnFieldAccess::VT_THREAD, thread);
  }
  void add_method(::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaMethod> method) {
    fbb_.AddOffset(OnFieldAccess::VT_METHOD, method);
  }
  void add_location(int64_t location) {
    fbb_.AddElement<int64_t>(OnFieldAccess::VT_LOCATION, location, 0);
  }
  void add_class_(::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaClass> class_) {
    fbb_.AddOffset(OnFieldAccess::VT_CLASS_, class_);
  }
  void add_object(::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaObject> object) {
    fbb_.AddOffset(OnFieldAccess::VT_OBJECT, object);
  }
  void add_field(::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaField> field) {
    fbb_.AddOffset(OnFieldAccess::VT_FIELD, field);
  }
  explicit OnFieldAccessBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OnFieldAccess> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OnFieldAccess>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OnFieldAccess> CreateOnFieldAccess(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaThread> thread = 0,
    ::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaMethod> method = 0,
    int64_t location = 0,
    ::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaClass> class_ = 0,
    ::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaObject> object = 0,
    ::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaField> field = 0) {
  OnFieldAccessBuilder builder_(_fbb);
  builder_.add_location(location);
  builder_.add_field(field);
  builder_.add_object(object);
  builder_.add_class_(class_);
  builder_.add_method(method);
  builder_.add_thread(thread);
  return builder_.Finish();
}

struct OnFieldModification FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OnFieldModificationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_THREAD = 4,
    VT_METHOD = 6,
    VT_LOCATION = 8,
    VT_CLASS_ = 10,
    VT_OBJECT = 12,
    VT_FIELD = 14,
    VT_SIGNATURE_TYPE = 16,
    VT_NEW_VALUE = 18
  };
  const jvm_toolbox_flatbuffers::inspector::JavaThread *thread() const {
    return GetPointer<const jvm_toolbox_flatbuffers::inspector::JavaThread *>(VT_THREAD);
  }
  const jvm_toolbox_flatbuffers::inspector::JavaMethod *method() const {
    return GetPointer<const jvm_toolbox_flatbuffers::inspector::JavaMethod *>(VT_METHOD);
  }
  int64_t location() const {
    return GetField<int64_t>(VT_LOCATION, 0);
  }
  const jvm_toolbox_flatbuffers::inspector::JavaClass *class_() const {
    return GetPointer<const jvm_toolbox_flatbuffers::inspector::JavaClass *>(VT_CLASS_);
  }
  const jvm_toolbox_flatbuffers::inspector::JavaObject *object() const {
    return GetPointer<const jvm_toolbox_flatbuffers::inspector::JavaObject *>(VT_OBJECT);
  }
  const jvm_toolbox_flatbuffers::inspector::JavaField *field() const {
    return GetPointer<const jvm_toolbox_flatbuffers::inspector::JavaField *>(VT_FIELD);
  }
  int8_t signature_type() const {
    return GetField<int8_t>(VT_SIGNATURE_TYPE, 0);
  }
  int64_t new_value() const {
    return GetField<int64_t>(VT_NEW_VALUE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_THREAD) &&
           verifier.VerifyTable(thread()) &&
           VerifyOffset(verifier, VT_METHOD) &&
           verifier.VerifyTable(method()) &&
           VerifyField<int64_t>(verifier, VT_LOCATION, 8) &&
           VerifyOffset(verifier, VT_CLASS_) &&
           verifier.VerifyTable(class_()) &&
           VerifyOffset(verifier, VT_OBJECT) &&
           verifier.VerifyTable(object()) &&
           VerifyOffset(verifier, VT_FIELD) &&
           verifier.VerifyTable(field()) &&
           VerifyField<int8_t>(verifier, VT_SIGNATURE_TYPE, 1) &&
           VerifyField<int64_t>(verifier, VT_NEW_VALUE, 8) &&
           verifier.EndTable();
  }
};

struct OnFieldModificationBuilder {
  typedef OnFieldModification Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_thread(::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaThread> thread) {
    fbb_.AddOffset(OnFieldModification::VT_THREAD, thread);
  }
  void add_method(::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaMethod> method) {
    fbb_.AddOffset(OnFieldModification::VT_METHOD, method);
  }
  void add_location(int64_t location) {
    fbb_.AddElement<int64_t>(OnFieldModification::VT_LOCATION, location, 0);
  }
  void add_class_(::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaClass> class_) {
    fbb_.AddOffset(OnFieldModification::VT_CLASS_, class_);
  }
  void add_object(::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaObject> object) {
    fbb_.AddOffset(OnFieldModification::VT_OBJECT, object);
  }
  void add_field(::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaField> field) {
    fbb_.AddOffset(OnFieldModification::VT_FIELD, field);
  }
  void add_signature_type(int8_t signature_type) {
    fbb_.AddElement<int8_t>(OnFieldModification::VT_SIGNATURE_TYPE, signature_type, 0);
  }
  void add_new_value(int64_t new_value) {
    fbb_.AddElement<int64_t>(OnFieldModification::VT_NEW_VALUE, new_value, 0);
  }
  explicit OnFieldModificationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OnFieldModification> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OnFieldModification>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OnFieldModification> CreateOnFieldModification(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaThread> thread = 0,
    ::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaMethod> method = 0,
    int64_t location = 0,
    ::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaClass> class_ = 0,
    ::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaObject> object = 0,
    ::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaField> field = 0,
    int8_t signature_type = 0,
    int64_t new_value = 0) {
  OnFieldModificationBuilder builder_(_fbb);
  builder_.add_new_value(new_value);
  builder_.add_location(location);
  builder_.add_field(field);
  builder_.add_object(object);
  builder_.add_class_(class_);
  builder_.add_method(method);
  builder_.add_thread(thread);
  builder_.add_signature_type(signature_type);
  return builder_.Finish();
}

struct OnFramePop FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OnFramePopBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_THREAD = 4,
    VT_METHOD = 6,
    VT_WAS_POPPED_BY_EXCEPTION = 8
  };
  const jvm_toolbox_flatbuffers::inspector::JavaThread *thread() const {
    return GetPointer<const jvm_toolbox_flatbuffers::inspector::JavaThread *>(VT_THREAD);
  }
  const jvm_toolbox_flatbuffers::inspector::JavaMethod *method() const {
    return GetPointer<const jvm_toolbox_flatbuffers::inspector::JavaMethod *>(VT_METHOD);
  }
  bool was_popped_by_exception() const {
    return GetField<uint8_t>(VT_WAS_POPPED_BY_EXCEPTION, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_THREAD) &&
           verifier.VerifyTable(thread()) &&
           VerifyOffset(verifier, VT_METHOD) &&
           verifier.VerifyTable(method()) &&
           VerifyField<uint8_t>(verifier, VT_WAS_POPPED_BY_EXCEPTION, 1) &&
           verifier.EndTable();
  }
};

struct OnFramePopBuilder {
  typedef OnFramePop Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_thread(::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaThread> thread) {
    fbb_.AddOffset(OnFramePop::VT_THREAD, thread);
  }
  void add_method(::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaMethod> method) {
    fbb_.AddOffset(OnFramePop::VT_METHOD, method);
  }
  void add_was_popped_by_exception(bool was_popped_by_exception) {
    fbb_.AddElement<uint8_t>(OnFramePop::VT_WAS_POPPED_BY_EXCEPTION, static_cast<uint8_t>(was_popped_by_exception), 0);
  }
  explicit OnFramePopBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OnFramePop> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OnFramePop>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OnFramePop> CreateOnFramePop(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaThread> thread = 0,
    ::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaMethod> method = 0,
    bool was_popped_by_exception = false) {
  OnFramePopBuilder builder_(_fbb);
  builder_.add_method(method);
  builder_.add_thread(thread);
  builder_.add_was_popped_by_exception(was_popped_by_exception);
  return builder_.Finish();
}

struct OnException FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OnExceptionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_THREAD = 4,
    VT_METHOD = 6,
    VT_LOCATION = 8,
    VT_EXCEPTION = 10,
    VT_CATCH_METHOD = 12,
    VT_CATCH_LOCATION = 14
  };
  const jvm_toolbox_flatbuffers::inspector::JavaThread *thread() const {
    return GetPointer<const jvm_toolbox_flatbuffers::inspector::JavaThread *>(VT_THREAD);
  }
  const jvm_toolbox_flatbuffers::inspector::JavaMethod *method() const {
    return GetPointer<const jvm_toolbox_flatbuffers::inspector::JavaMethod *>(VT_METHOD);
  }
  int64_t location() const {
    return GetField<int64_t>(VT_LOCATION, 0);
  }
  const jvm_toolbox_flatbuffers::inspector::JavaObject *exception() const {
    return GetPointer<const jvm_toolbox_flatbuffers::inspector::JavaObject *>(VT_EXCEPTION);
  }
  const jvm_toolbox_flatbuffers::inspector::JavaMethod *catch_method() const {
    return GetPointer<const jvm_toolbox_flatbuffers::inspector::JavaMethod *>(VT_CATCH_METHOD);
  }
  int64_t catch_location() const {
    return GetField<int64_t>(VT_CATCH_LOCATION, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_THREAD) &&
           verifier.VerifyTable(thread()) &&
           VerifyOffset(verifier, VT_METHOD) &&
           verifier.VerifyTable(method()) &&
           VerifyField<int64_t>(verifier, VT_LOCATION, 8) &&
           VerifyOffset(verifier, VT_EXCEPTION) &&
           verifier.VerifyTable(exception()) &&
           VerifyOffset(verifier, VT_CATCH_METHOD) &&
           verifier.VerifyTable(catch_method()) &&
           VerifyField<int64_t>(verifier, VT_CATCH_LOCATION, 8) &&
           verifier.EndTable();
  }
};

struct OnExceptionBuilder {
  typedef OnException Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_thread(::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaThread> thread) {
    fbb_.AddOffset(OnException::VT_THREAD, thread);
  }
  void add_method(::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaMethod> method) {
    fbb_.AddOffset(OnException::VT_METHOD, method);
  }
  void add_location(int64_t location) {
    fbb_.AddElement<int64_t>(OnException::VT_LOCATION, location, 0);
  }
  void add_exception(::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaObject> exception) {
    fbb_.AddOffset(OnException::VT_EXCEPTION, exception);
  }
  void add_catch_method(::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaMethod> catch_method) {
    fbb_.AddOffset(OnException::VT_CATCH_METHOD, catch_method);
  }
  void add_catch_location(int64_t catch_location) {
    fbb_.AddElement<int64_t>(OnException::VT_CATCH_LOCATION, catch_location, 0);
  }
  explicit OnExceptionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OnException> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OnException>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OnException> CreateOnException(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaThread> thread = 0,
    ::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaMethod> method = 0,
    int64_t location = 0,
    ::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaObject> exception = 0,
    ::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaMethod> catch_method = 0,
    int64_t catch_location = 0) {
  OnExceptionBuilder builder_(_fbb);
  builder_.add_catch_location(catch_location);
  builder_.add_location(location);
  builder_.add_catch_method(catch_method);
  builder_.add_exception(exception);
  builder_.add_method(method);
  builder_.add_thread(thread);
  return builder_.Finish();
}

struct OnExceptionCatch FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OnExceptionCatchBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_THREAD = 4,
    VT_METHOD = 6,
    VT_LOCATION = 8,
    VT_EXCEPTION = 10
  };
  const jvm_toolbox_flatbuffers::inspector::JavaThread *thread() const {
    return GetPointer<const jvm_toolbox_flatbuffers::inspector::JavaThread *>(VT_THREAD);
  }
  const jvm_toolbox_flatbuffers::inspector::JavaMethod *method() const {
    return GetPointer<const jvm_toolbox_flatbuffers::inspector::JavaMethod *>(VT_METHOD);
  }
  int64_t location() const {
    return GetField<int64_t>(VT_LOCATION, 0);
  }
  const jvm_toolbox_flatbuffers::inspector::JavaObject *exception() const {
    return GetPointer<const jvm_toolbox_flatbuffers::inspector::JavaObject *>(VT_EXCEPTION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_THREAD) &&
           verifier.VerifyTable(thread()) &&
           VerifyOffset(verifier, VT_METHOD) &&
           verifier.VerifyTable(method()) &&
           VerifyField<int64_t>(verifier, VT_LOCATION, 8) &&
           VerifyOffset(verifier, VT_EXCEPTION) &&
           verifier.VerifyTable(exception()) &&
           verifier.EndTable();
  }
};

struct OnExceptionCatchBuilder {
  typedef OnExceptionCatch Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_thread(::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaThread> thread) {
    fbb_.AddOffset(OnExceptionCatch::VT_THREAD, thread);
  }
  void add_method(::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaMethod> method) {
    fbb_.AddOffset(OnExceptionCatch::VT_METHOD, method);
  }
  void add_location(int64_t location) {
    fbb_.AddElement<int64_t>(OnExceptionCatch::VT_LOCATION, location, 0);
  }
  void add_exception(::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaObject> exception) {
    fbb_.AddOffset(OnExceptionCatch::VT_EXCEPTION, exception);
  }
  explicit OnExceptionCatchBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OnExceptionCatch> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OnExceptionCatch>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OnExceptionCatch> CreateOnExceptionCatch(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaThread> thread = 0,
    ::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaMethod> method = 0,
    int64_t location = 0,
    ::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaObject> exception = 0) {
  OnExceptionCatchBuilder builder_(_fbb);
  builder_.add_location(location);
  builder_.add_exception(exception);
  builder_.add_method(method);
  builder_.add_thread(thread);
  return builder_.Finish();
}

struct OnThreadStart FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OnThreadStartBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_THREAD = 4
  };
  const jvm_toolbox_flatbuffers::inspector::JavaThread *thread() const {
    return GetPointer<const jvm_toolbox_flatbuffers::inspector::JavaThread *>(VT_THREAD);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_THREAD) &&
           verifier.VerifyTable(thread()) &&
           verifier.EndTable();
  }
};

struct OnThreadStartBuilder {
  typedef OnThreadStart Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_thread(::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaThread> thread) {
    fbb_.AddOffset(OnThreadStart::VT_THREAD, thread);
  }
  explicit OnThreadStartBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OnThreadStart> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OnThreadStart>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OnThreadStart> CreateOnThreadStart(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaThread> thread = 0) {
  OnThreadStartBuilder builder_(_fbb);
  builder_.add_thread(thread);
  return builder_.Finish();
}

struct OnThreadEnd FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OnThreadEndBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_THREAD = 4
  };
  const jvm_toolbox_flatbuffers::inspector::JavaThread *thread() const {
    return GetPointer<const jvm_toolbox_flatbuffers::inspector::JavaThread *>(VT_THREAD);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_THREAD) &&
           verifier.VerifyTable(thread()) &&
           verifier.EndTable();
  }
};

struct OnThreadEndBuilder {
  typedef OnThreadEnd Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_thread(::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaThread> thread) {
    fbb_.AddOffset(OnThreadEnd::VT_THREAD, thread);
  }
  explicit OnThreadEndBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OnThreadEnd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OnThreadEnd>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OnThreadEnd> CreateOnThreadEnd(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaThread> thread = 0) {
  OnThreadEndBuilder builder_(_fbb);
  builder_.add_thread(thread);
  return builder_.Finish();
}

struct OnClassLoad FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OnClassLoadBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_THREAD = 4,
    VT_CLASS_ = 6
  };
  const jvm_toolbox_flatbuffers::inspector::JavaThread *thread() const {
    return GetPointer<const jvm_toolbox_flatbuffers::inspector::JavaThread *>(VT_THREAD);
  }
  const jvm_toolbox_flatbuffers::inspector::JavaClass *class_() const {
    return GetPointer<const jvm_toolbox_flatbuffers::inspector::JavaClass *>(VT_CLASS_);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_THREAD) &&
           verifier.VerifyTable(thread()) &&
           VerifyOffset(verifier, VT_CLASS_) &&
           verifier.VerifyTable(class_()) &&
           verifier.EndTable();
  }
};

struct OnClassLoadBuilder {
  typedef OnClassLoad Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_thread(::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaThread> thread) {
    fbb_.AddOffset(OnClassLoad::VT_THREAD, thread);
  }
  void add_class_(::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaClass> class_) {
    fbb_.AddOffset(OnClassLoad::VT_CLASS_, class_);
  }
  explicit OnClassLoadBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OnClassLoad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OnClassLoad>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OnClassLoad> CreateOnClassLoad(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaThread> thread = 0,
    ::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaClass> class_ = 0) {
  OnClassLoadBuilder builder_(_fbb);
  builder_.add_class_(class_);
  builder_.add_thread(thread);
  return builder_.Finish();
}

struct OnClassPrepare FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OnClassPrepareBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_THREAD = 4,
    VT_CLASS_ = 6
  };
  const jvm_toolbox_flatbuffers::inspector::JavaThread *thread() const {
    return GetPointer<const jvm_toolbox_flatbuffers::inspector::JavaThread *>(VT_THREAD);
  }
  const jvm_toolbox_flatbuffers::inspector::JavaClass *class_() const {
    return GetPointer<const jvm_toolbox_flatbuffers::inspector::JavaClass *>(VT_CLASS_);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_THREAD) &&
           verifier.VerifyTable(thread()) &&
           VerifyOffset(verifier, VT_CLASS_) &&
           verifier.VerifyTable(class_()) &&
           verifier.EndTable();
  }
};

struct OnClassPrepareBuilder {
  typedef OnClassPrepare Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_thread(::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaThread> thread) {
    fbb_.AddOffset(OnClassPrepare::VT_THREAD, thread);
  }
  void add_class_(::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaClass> class_) {
    fbb_.AddOffset(OnClassPrepare::VT_CLASS_, class_);
  }
  explicit OnClassPrepareBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OnClassPrepare> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OnClassPrepare>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OnClassPrepare> CreateOnClassPrepare(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaThread> thread = 0,
    ::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaClass> class_ = 0) {
  OnClassPrepareBuilder builder_(_fbb);
  builder_.add_class_(class_);
  builder_.add_thread(thread);
  return builder_.Finish();
}

struct OnClassFileLoad FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OnClassFileLoadBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_CLASS_ = 6,
    VT_LOADER = 8,
    VT_BYTECODE = 10
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const jvm_toolbox_flatbuffers::inspector::JavaClass *class_() const {
    return GetPointer<const jvm_toolbox_flatbuffers::inspector::JavaClass *>(VT_CLASS_);
  }
  const jvm_toolbox_flatbuffers::inspector::JavaObject *loader() const {
    return GetPointer<const jvm_toolbox_flatbuffers::inspector::JavaObject *>(VT_LOADER);
  }
  const ::flatbuffers::Vector<int8_t> *bytecode() const {
    return GetPointer<const ::flatbuffers::Vector<int8_t> *>(VT_BYTECODE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_CLASS_) &&
           verifier.VerifyTable(class_()) &&
           VerifyOffset(verifier, VT_LOADER) &&
           verifier.VerifyTable(loader()) &&
           VerifyOffset(verifier, VT_BYTECODE) &&
           verifier.VerifyVector(bytecode()) &&
           verifier.EndTable();
  }
};

struct OnClassFileLoadBuilder {
  typedef OnClassFileLoad Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(OnClassFileLoad::VT_NAME, name);
  }
  void add_class_(::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaClass> class_) {
    fbb_.AddOffset(OnClassFileLoad::VT_CLASS_, class_);
  }
  void add_loader(::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaObject> loader) {
    fbb_.AddOffset(OnClassFileLoad::VT_LOADER, loader);
  }
  void add_bytecode(::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> bytecode) {
    fbb_.AddOffset(OnClassFileLoad::VT_BYTECODE, bytecode);
  }
  explicit OnClassFileLoadBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OnClassFileLoad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OnClassFileLoad>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OnClassFileLoad> CreateOnClassFileLoad(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaClass> class_ = 0,
    ::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaObject> loader = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> bytecode = 0) {
  OnClassFileLoadBuilder builder_(_fbb);
  builder_.add_bytecode(bytecode);
  builder_.add_loader(loader);
  builder_.add_class_(class_);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<OnClassFileLoad> CreateOnClassFileLoadDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    ::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaClass> class_ = 0,
    ::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaObject> loader = 0,
    const std::vector<int8_t> *bytecode = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto bytecode__ = bytecode ? _fbb.CreateVector<int8_t>(*bytecode) : 0;
  return jvm_toolbox_flatbuffers::inspector::CreateOnClassFileLoad(
      _fbb,
      name__,
      class_,
      loader,
      bytecode__);
}

struct OnVMDeath FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OnVMDeathBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct OnVMDeathBuilder {
  typedef OnVMDeath Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit OnVMDeathBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OnVMDeath> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OnVMDeath>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OnVMDeath> CreateOnVMDeath(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  OnVMDeathBuilder builder_(_fbb);
  return builder_.Finish();
}

struct OnVMObjectAllocated FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OnVMObjectAllocatedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_THREAD = 4,
    VT_OBJECT = 6,
    VT_SIZE = 8,
    VT_CLASS_ = 10
  };
  const jvm_toolbox_flatbuffers::inspector::JavaThread *thread() const {
    return GetPointer<const jvm_toolbox_flatbuffers::inspector::JavaThread *>(VT_THREAD);
  }
  const jvm_toolbox_flatbuffers::inspector::JavaObject *object() const {
    return GetPointer<const jvm_toolbox_flatbuffers::inspector::JavaObject *>(VT_OBJECT);
  }
  int64_t size() const {
    return GetField<int64_t>(VT_SIZE, 0);
  }
  const jvm_toolbox_flatbuffers::inspector::JavaClass *class_() const {
    return GetPointer<const jvm_toolbox_flatbuffers::inspector::JavaClass *>(VT_CLASS_);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_THREAD) &&
           verifier.VerifyTable(thread()) &&
           VerifyOffset(verifier, VT_OBJECT) &&
           verifier.VerifyTable(object()) &&
           VerifyField<int64_t>(verifier, VT_SIZE, 8) &&
           VerifyOffset(verifier, VT_CLASS_) &&
           verifier.VerifyTable(class_()) &&
           verifier.EndTable();
  }
};

struct OnVMObjectAllocatedBuilder {
  typedef OnVMObjectAllocated Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_thread(::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaThread> thread) {
    fbb_.AddOffset(OnVMObjectAllocated::VT_THREAD, thread);
  }
  void add_object(::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaObject> object) {
    fbb_.AddOffset(OnVMObjectAllocated::VT_OBJECT, object);
  }
  void add_size(int64_t size) {
    fbb_.AddElement<int64_t>(OnVMObjectAllocated::VT_SIZE, size, 0);
  }
  void add_class_(::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaClass> class_) {
    fbb_.AddOffset(OnVMObjectAllocated::VT_CLASS_, class_);
  }
  explicit OnVMObjectAllocatedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OnVMObjectAllocated> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OnVMObjectAllocated>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OnVMObjectAllocated> CreateOnVMObjectAllocated(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaThread> thread = 0,
    ::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaObject> object = 0,
    int64_t size = 0,
    ::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaClass> class_ = 0) {
  OnVMObjectAllocatedBuilder builder_(_fbb);
  builder_.add_size(size);
  builder_.add_class_(class_);
  builder_.add_object(object);
  builder_.add_thread(thread);
  return builder_.Finish();
}

struct OnVMObjectFree FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OnVMObjectFreeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TAG = 4
  };
  int64_t tag() const {
    return GetField<int64_t>(VT_TAG, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_TAG, 8) &&
           verifier.EndTable();
  }
};

struct OnVMObjectFreeBuilder {
  typedef OnVMObjectFree Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_tag(int64_t tag) {
    fbb_.AddElement<int64_t>(OnVMObjectFree::VT_TAG, tag, 0);
  }
  explicit OnVMObjectFreeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OnVMObjectFree> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OnVMObjectFree>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OnVMObjectFree> CreateOnVMObjectFree(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t tag = 0) {
  OnVMObjectFreeBuilder builder_(_fbb);
  builder_.add_tag(tag);
  return builder_.Finish();
}

}  // namespace inspector
}  // namespace jvm_toolbox_flatbuffers

#endif  // FLATBUFFERS_GENERATED_INSPECTORDATA_JVM_TOOLBOX_FLATBUFFERS_INSPECTOR_H_
