// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_INSPECTORINFO_JVM_TOOLBOX_FLATBUFFERS_INSPECTOR_H_
#define FLATBUFFERS_GENERATED_INSPECTORINFO_JVM_TOOLBOX_FLATBUFFERS_INSPECTOR_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 9,
             "Non-compatible flatbuffers version included");

namespace jvm_toolbox_flatbuffers {
namespace inspector {

struct JavaMethod;
struct JavaMethodBuilder;

struct JavaField;
struct JavaFieldBuilder;

struct JavaClass;
struct JavaClassBuilder;

struct JavaThread;
struct JavaThreadBuilder;

struct OnInspectorLoaded;
struct OnInspectorLoadedBuilder;

struct JavaMethod FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef JavaMethodBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_SIGNATURE = 6,
    VT_ADDRESS = 8
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *signature() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SIGNATURE);
  }
  int64_t address() const {
    return GetField<int64_t>(VT_ADDRESS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_SIGNATURE) &&
           verifier.VerifyString(signature()) &&
           VerifyField<int64_t>(verifier, VT_ADDRESS, 8) &&
           verifier.EndTable();
  }
};

struct JavaMethodBuilder {
  typedef JavaMethod Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(JavaMethod::VT_NAME, name);
  }
  void add_signature(::flatbuffers::Offset<::flatbuffers::String> signature) {
    fbb_.AddOffset(JavaMethod::VT_SIGNATURE, signature);
  }
  void add_address(int64_t address) {
    fbb_.AddElement<int64_t>(JavaMethod::VT_ADDRESS, address, 0);
  }
  explicit JavaMethodBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<JavaMethod> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<JavaMethod>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<JavaMethod> CreateJavaMethod(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> signature = 0,
    int64_t address = 0) {
  JavaMethodBuilder builder_(_fbb);
  builder_.add_address(address);
  builder_.add_signature(signature);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<JavaMethod> CreateJavaMethodDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *signature = nullptr,
    int64_t address = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto signature__ = signature ? _fbb.CreateString(signature) : 0;
  return jvm_toolbox_flatbuffers::inspector::CreateJavaMethod(
      _fbb,
      name__,
      signature__,
      address);
}

struct JavaField FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef JavaFieldBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_SIGNATURE = 6,
    VT_ADDRESS = 8
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *signature() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SIGNATURE);
  }
  int64_t address() const {
    return GetField<int64_t>(VT_ADDRESS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_SIGNATURE) &&
           verifier.VerifyString(signature()) &&
           VerifyField<int64_t>(verifier, VT_ADDRESS, 8) &&
           verifier.EndTable();
  }
};

struct JavaFieldBuilder {
  typedef JavaField Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(JavaField::VT_NAME, name);
  }
  void add_signature(::flatbuffers::Offset<::flatbuffers::String> signature) {
    fbb_.AddOffset(JavaField::VT_SIGNATURE, signature);
  }
  void add_address(int64_t address) {
    fbb_.AddElement<int64_t>(JavaField::VT_ADDRESS, address, 0);
  }
  explicit JavaFieldBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<JavaField> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<JavaField>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<JavaField> CreateJavaField(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> signature = 0,
    int64_t address = 0) {
  JavaFieldBuilder builder_(_fbb);
  builder_.add_address(address);
  builder_.add_signature(signature);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<JavaField> CreateJavaFieldDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *signature = nullptr,
    int64_t address = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto signature__ = signature ? _fbb.CreateString(signature) : 0;
  return jvm_toolbox_flatbuffers::inspector::CreateJavaField(
      _fbb,
      name__,
      signature__,
      address);
}

struct JavaClass FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef JavaClassBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SIGNATURE = 4,
    VT_ADDRESS = 6,
    VT_METHODS = 8,
    VT_FIELDS = 10
  };
  const ::flatbuffers::String *signature() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SIGNATURE);
  }
  int64_t address() const {
    return GetField<int64_t>(VT_ADDRESS, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaMethod>> *methods() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaMethod>> *>(VT_METHODS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaField>> *fields() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaField>> *>(VT_FIELDS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SIGNATURE) &&
           verifier.VerifyString(signature()) &&
           VerifyField<int64_t>(verifier, VT_ADDRESS, 8) &&
           VerifyOffset(verifier, VT_METHODS) &&
           verifier.VerifyVector(methods()) &&
           verifier.VerifyVectorOfTables(methods()) &&
           VerifyOffset(verifier, VT_FIELDS) &&
           verifier.VerifyVector(fields()) &&
           verifier.VerifyVectorOfTables(fields()) &&
           verifier.EndTable();
  }
};

struct JavaClassBuilder {
  typedef JavaClass Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_signature(::flatbuffers::Offset<::flatbuffers::String> signature) {
    fbb_.AddOffset(JavaClass::VT_SIGNATURE, signature);
  }
  void add_address(int64_t address) {
    fbb_.AddElement<int64_t>(JavaClass::VT_ADDRESS, address, 0);
  }
  void add_methods(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaMethod>>> methods) {
    fbb_.AddOffset(JavaClass::VT_METHODS, methods);
  }
  void add_fields(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaField>>> fields) {
    fbb_.AddOffset(JavaClass::VT_FIELDS, fields);
  }
  explicit JavaClassBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<JavaClass> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<JavaClass>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<JavaClass> CreateJavaClass(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> signature = 0,
    int64_t address = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaMethod>>> methods = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaField>>> fields = 0) {
  JavaClassBuilder builder_(_fbb);
  builder_.add_address(address);
  builder_.add_fields(fields);
  builder_.add_methods(methods);
  builder_.add_signature(signature);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<JavaClass> CreateJavaClassDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *signature = nullptr,
    int64_t address = 0,
    const std::vector<::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaMethod>> *methods = nullptr,
    const std::vector<::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaField>> *fields = nullptr) {
  auto signature__ = signature ? _fbb.CreateString(signature) : 0;
  auto methods__ = methods ? _fbb.CreateVector<::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaMethod>>(*methods) : 0;
  auto fields__ = fields ? _fbb.CreateVector<::flatbuffers::Offset<jvm_toolbox_flatbuffers::inspector::JavaField>>(*fields) : 0;
  return jvm_toolbox_flatbuffers::inspector::CreateJavaClass(
      _fbb,
      signature__,
      address,
      methods__,
      fields__);
}

struct JavaThread FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef JavaThreadBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATE = 4,
    VT_NAME = 6,
    VT_PRIORITY = 8,
    VT_IS_DAEMON = 10
  };
  int32_t state() const {
    return GetField<int32_t>(VT_STATE, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  int32_t priority() const {
    return GetField<int32_t>(VT_PRIORITY, 0);
  }
  bool is_daemon() const {
    return GetField<uint8_t>(VT_IS_DAEMON, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_STATE, 4) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int32_t>(verifier, VT_PRIORITY, 4) &&
           VerifyField<uint8_t>(verifier, VT_IS_DAEMON, 1) &&
           verifier.EndTable();
  }
};

struct JavaThreadBuilder {
  typedef JavaThread Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_state(int32_t state) {
    fbb_.AddElement<int32_t>(JavaThread::VT_STATE, state, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(JavaThread::VT_NAME, name);
  }
  void add_priority(int32_t priority) {
    fbb_.AddElement<int32_t>(JavaThread::VT_PRIORITY, priority, 0);
  }
  void add_is_daemon(bool is_daemon) {
    fbb_.AddElement<uint8_t>(JavaThread::VT_IS_DAEMON, static_cast<uint8_t>(is_daemon), 0);
  }
  explicit JavaThreadBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<JavaThread> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<JavaThread>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<JavaThread> CreateJavaThread(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t state = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    int32_t priority = 0,
    bool is_daemon = false) {
  JavaThreadBuilder builder_(_fbb);
  builder_.add_priority(priority);
  builder_.add_name(name);
  builder_.add_state(state);
  builder_.add_is_daemon(is_daemon);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<JavaThread> CreateJavaThreadDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t state = 0,
    const char *name = nullptr,
    int32_t priority = 0,
    bool is_daemon = false) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return jvm_toolbox_flatbuffers::inspector::CreateJavaThread(
      _fbb,
      state,
      name__,
      priority,
      is_daemon);
}

struct OnInspectorLoaded FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OnInspectorLoadedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INSPECTOR_INTERFACE = 4
  };
  const ::flatbuffers::String *inspector_interface() const {
    return GetPointer<const ::flatbuffers::String *>(VT_INSPECTOR_INTERFACE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INSPECTOR_INTERFACE) &&
           verifier.VerifyString(inspector_interface()) &&
           verifier.EndTable();
  }
};

struct OnInspectorLoadedBuilder {
  typedef OnInspectorLoaded Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_inspector_interface(::flatbuffers::Offset<::flatbuffers::String> inspector_interface) {
    fbb_.AddOffset(OnInspectorLoaded::VT_INSPECTOR_INTERFACE, inspector_interface);
  }
  explicit OnInspectorLoadedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OnInspectorLoaded> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OnInspectorLoaded>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OnInspectorLoaded> CreateOnInspectorLoaded(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> inspector_interface = 0) {
  OnInspectorLoadedBuilder builder_(_fbb);
  builder_.add_inspector_interface(inspector_interface);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<OnInspectorLoaded> CreateOnInspectorLoadedDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *inspector_interface = nullptr) {
  auto inspector_interface__ = inspector_interface ? _fbb.CreateString(inspector_interface) : 0;
  return jvm_toolbox_flatbuffers::inspector::CreateOnInspectorLoaded(
      _fbb,
      inspector_interface__);
}

}  // namespace inspector
}  // namespace jvm_toolbox_flatbuffers

#endif  // FLATBUFFERS_GENERATED_INSPECTORINFO_JVM_TOOLBOX_FLATBUFFERS_INSPECTOR_H_
